#include <ble_printer_manager.h>

// Printer constants
const uint8_t PRINTER_ID[8] = {0x1B, 0x2F, 0x03, 0x01, 0x00, 0x01, 0x00, 0x01};

// BLE globals
NimBLERemoteService *pPrinterService = nullptr;
NimBLEClient *pClient = nullptr;
NimBLERemoteCharacteristic *pWriteChar = nullptr;
NimBLERemoteCharacteristic *pNotifyChar = nullptr;

// Print job state
volatile bool ackReceived = false;
std::vector<uint8_t> lastAck;
bool printingInProgress = false;

// Frame storage for current print job
std::vector<std::vector<uint8_t>> printFrames;
int currentFrameIndex = 0;

// ============================================================================
// FRAME CONSTRUCTION
// ============================================================================

// Calculate checksum for frame
uint8_t calculateFrameChecksum(const uint8_t *data, size_t len) {
  uint8_t checksum = 0;
  for (size_t i = 0; i < len - 1; i++) {
    checksum = (checksum - data[i]) & 0xFF;
  }
  return checksum;
}

// ============================================================================
// PRINT JOB MANAGEMENT
// ============================================================================

// Prepare frames from compressed bitmap data
bool prepareFramesFromBitmap(const Bitmap &userBitmap) {
  // Clear previous frames
  printFrames.clear();

  // Use the new Python-style compression
  auto frames = compressAndGenerateFrames(userBitmap);

  if (frames.empty()) {
    Serial.println("No frames generated!");
    return false;
  }

  // Convert to the existing frame format
  for (const auto &frame : frames) {
    printFrames.push_back(frame.data);
  }

  Serial.printf("Total frames prepared: %d\n", printFrames.size());

  return true;
}

// Set example frames (for testing with hardcoded data)
void setExampleBitmapFrame() {
  printFrames.clear();

  // Frame 1 - 248 bytes
  printFrames.push_back(
      {0x66, 0x45, 0x01, 0x1B, 0x2F, 0x03, 0x01, 0x00, 0x01, 0x00, 0x01, 0xFF,
       0x00, 0x55, 0x00, 0x02, 0x00, 0x03, 0x20, 0x02, 0x02, 0x22, 0x22, 0x20,
       0x30, 0x14, 0x00, 0x03, 0xE0, 0x03, 0x03, 0x3E, 0x3E, 0xE0, 0xB4, 0x00,
       0x30, 0x74, 0x00, 0xA5, 0x02, 0x00, 0x29, 0x00, 0x00, 0xA4, 0x05, 0xB4,
       0x00, 0x03, 0x40, 0x00, 0x00, 0x04, 0x04, 0x40, 0xB4, 0x00, 0x03, 0x80,
       0x00, 0x00, 0x08, 0x08, 0x80, 0xB4, 0x00, 0x03, 0x00, 0x01, 0x01, 0x10,
       0x10, 0x00, 0xB4, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x29, 0x18, 0x01, 0x20,
       0x10, 0x28, 0x00, 0xA4, 0x08, 0xB4, 0x00, 0xA4, 0x0E, 0xB4, 0x00, 0xA4,
       0x0E, 0xB4, 0x00, 0xA4, 0x02, 0xB4, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x2A,
       0xB0, 0x01, 0x03, 0x20, 0x00, 0x00, 0x02, 0x02, 0x20, 0xB4, 0x00, 0xA4,
       0x05, 0xB4, 0x00, 0x03, 0x80, 0x03, 0x03, 0x38, 0x38, 0x80, 0xB4, 0x00,
       0xA4, 0x02, 0xB4, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x2A, 0x1C, 0x01, 0x20,
       0x0F, 0x2C, 0x00, 0xA4, 0x11, 0xB4, 0x00, 0xB4, 0x15, 0x3C, 0x14, 0x00,
       0xA4, 0x05, 0xB4, 0x00, 0x2A, 0xAC, 0x01, 0xA4, 0x02, 0xB4, 0x00, 0x03,
       0xA0, 0x02, 0x02, 0x2A, 0x2A, 0xA0, 0x3C, 0x14, 0x00, 0xA4, 0x38, 0xB4,
       0x00, 0x2A, 0x1C, 0x01, 0x03, 0xC0, 0x03, 0x03, 0x3C, 0x3C, 0xC0, 0xB4,
       0x00, 0x03, 0xA0, 0x00, 0x00, 0x0A, 0x0A, 0xA0, 0x3C, 0x14, 0x00, 0xA4,
       0x05, 0xB4, 0x00, 0x2A, 0x1C, 0x01, 0xA4, 0x11, 0xB4, 0x00, 0xB4, 0x0C,
       0x3C, 0x14, 0x00, 0x03, 0xC0, 0x01, 0x01, 0x1C, 0x1C, 0xC0, 0xB4, 0x00,
       0x2A, 0x1C, 0x01, 0x20, 0x0F, 0x2C, 0x00, 0x36, 0x94, 0x01, 0xA4, 0x11,
       0xB4, 0x00, 0x36, 0x8C, 0x00, 0x2A, 0xAC, 0x01});

  // Frame 2 - 77 bytes
  printFrames.push_back(
      {0xA4, 0x05, 0xB4, 0x00, 0xA4, 0x3E, 0xB4, 0x00, 0x2A, 0x74, 0x06,
       0xA4, 0x59, 0xB4, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x2A, 0x1C, 0x01,
       0x20, 0x0F, 0x2C, 0x00, 0xA4, 0x08, 0xB4, 0x00, 0xA4, 0x0E, 0xB4,
       0x00, 0x2A, 0xDC, 0x01, 0xA4, 0x02, 0xB4, 0x00, 0xA4, 0x05, 0xB4,
       0x00, 0x2A, 0xAC, 0x01, 0xA4, 0x53, 0xB4, 0x00, 0xA4, 0x05, 0x0F,
       0x40, 0x00, 0x00, 0x04, 0x04, 0x40, 0x80, 0x03, 0x03, 0x38, 0x38,
       0x80, 0x80, 0x03, 0x03, 0x38, 0x38, 0x80, 0x11, 0x00, 0x00, 0xEE});

  // Frame 3 - 248 bytes
  printFrames.push_back(
      {0x66, 0x33, 0x01, 0x1B, 0x2F, 0x03, 0x01, 0x00, 0x01, 0x00, 0x01, 0xFF,
       0x00, 0x55, 0x00, 0x01, 0x00, 0x03, 0x40, 0x00, 0x00, 0x04, 0x04, 0x40,
       0xB4, 0x00, 0x03, 0x20, 0x00, 0x00, 0x02, 0x02, 0x20, 0xB5, 0x00, 0x00,
       0x20, 0x1A, 0x00, 0x00, 0x03, 0xE0, 0x03, 0x03, 0x3E, 0x3E, 0xE0, 0xB4,
       0x00, 0x03, 0x80, 0x00, 0x00, 0x08, 0x08, 0x80, 0x3C, 0x14, 0x00, 0xA4,
       0x05, 0xB4, 0x00, 0x2A, 0xD8, 0x01, 0xA4, 0x02, 0xB4, 0x00, 0x03, 0xA0,
       0x02, 0x02, 0x2A, 0x2A, 0xA0, 0x3C, 0x14, 0x00, 0x03, 0x20, 0x02, 0x02,
       0x22, 0x22, 0x20, 0xB4, 0x00, 0x2A, 0x1C, 0x01, 0x03, 0xC0, 0x03, 0x03,
       0x3C, 0x3C, 0xC0, 0xB4, 0x00, 0x03, 0xA0, 0x00, 0x00, 0x0A, 0x0A, 0xA0,
       0x3C, 0x14, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x2A, 0x1C, 0x01, 0xA4, 0x11,
       0xB4, 0x00, 0xB4, 0x0C, 0x3C, 0x14, 0x00, 0x03, 0xC0, 0x01, 0x01, 0x1C,
       0x1C, 0xC0, 0xB4, 0x00, 0x2A, 0x1C, 0x01, 0x20, 0x0F, 0x2C, 0x00, 0x36,
       0x94, 0x01, 0xA4, 0x11, 0xB4, 0x00, 0x36, 0x8C, 0x00, 0x2A, 0xAC, 0x01,
       0xA4, 0x05, 0xB4, 0x00, 0xA4, 0x3E, 0xB4, 0x00, 0x2A, 0x74, 0x06, 0x03,
       0x00, 0x01, 0x01, 0x10, 0x10, 0x00, 0xB4, 0x00, 0xA4, 0x05, 0xB4, 0x00,
       0x2A, 0x1C, 0x01, 0x20, 0x0F, 0x2C, 0x00, 0xA4, 0x08, 0xB4, 0x00, 0xA4,
       0x0E, 0xB4, 0x00, 0x2A, 0xDC, 0x01, 0xA4, 0x02, 0xB4, 0x00, 0xA4, 0x05,
       0xB4, 0x00, 0x2A, 0xAC, 0x01, 0xA4, 0x53, 0xB4, 0x00, 0xA4, 0x05, 0xB4,
       0x00, 0x03, 0x80, 0x03, 0x03, 0x38, 0x38, 0x80, 0xB4, 0x00, 0xA4, 0x02,
       0xB4, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x2A, 0x1C, 0x01, 0x20, 0x0F, 0x2C,
       0x00, 0xA4, 0x11, 0xB4, 0x00, 0x2A, 0xCC, 0x02});

  // Frame 4 - 59 bytes
  printFrames.push_back(
      {0x36, 0x2C, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x2A, 0xAC, 0x01, 0xA4, 0x02,
       0xB4, 0x00, 0x3C, 0x24, 0x0B, 0xB4, 0x03, 0x2A, 0x4C, 0x07, 0x2A, 0x1C,
       0x01, 0xA4, 0x53, 0xB4, 0x00, 0x3C, 0x24, 0x0B, 0xB4, 0x03, 0xA4, 0x05,
       0x0F, 0xC0, 0x03, 0x03, 0x3C, 0x3C, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x49});

  // Frame 5 - 248 bytes
  printFrames.push_back(
      {0x66, 0x33, 0x01, 0x1B, 0x2F, 0x03, 0x01, 0x00, 0x01, 0x00, 0x01, 0xFF,
       0x00, 0x55, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x03, 0x03, 0x3E, 0x3E, 0xE0,
       0xB4, 0x00, 0x03, 0x20, 0x02, 0x02, 0x22, 0x22, 0x20, 0x3C, 0x14, 0x00,
       0x03, 0xC0, 0x01, 0x01, 0x1C, 0x1C, 0xC0, 0xB5, 0x00, 0x00, 0x20, 0x1A,
       0x00, 0x00, 0x36, 0x94, 0x01, 0xA4, 0x11, 0xB4, 0x00, 0x36, 0x8C, 0x00,
       0x2A, 0xD8, 0x01, 0xA4, 0x05, 0xB4, 0x00, 0x03, 0x40, 0x00, 0x00, 0x04,
       0x04, 0x40, 0xB4, 0x00, 0x03, 0x80, 0x00, 0x00, 0x08, 0x08, 0x80, 0xB4,
       0x00, 0x03, 0x00, 0x01, 0x01, 0x10, 0x10, 0x00, 0xB4, 0x00, 0xA4, 0x05,
       0xB4, 0x00, 0x2A, 0x1C, 0x01, 0x20, 0x0F, 0x2C, 0x00, 0xA4, 0x08, 0xB4,
       0x00, 0xA4, 0x0E, 0xB4, 0x00, 0xA4, 0x0E, 0xB4, 0x00, 0xA4, 0x02, 0xB4,
       0x00, 0xA4, 0x05, 0xB4, 0x00, 0x2A, 0xAC, 0x01, 0x03, 0x20, 0x00, 0x00,
       0x02, 0x02, 0x20, 0xB4, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x03, 0x80, 0x03,
       0x03, 0x38, 0x38, 0x80, 0xB4, 0x00, 0xA4, 0x02, 0xB4, 0x00, 0xA4, 0x05,
       0xB4, 0x00, 0x2A, 0x1C, 0x01, 0x20, 0x0F, 0x2C, 0x00, 0xA4, 0x11, 0xB4,
       0x00, 0xB4, 0x15, 0x3C, 0x14, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x2A, 0xAC,
       0x01, 0xA4, 0x02, 0xB4, 0x00, 0x03, 0xA0, 0x02, 0x02, 0x2A, 0x2A, 0xA0,
       0x3C, 0x14, 0x00, 0x2A, 0x4C, 0x07, 0x2A, 0x1C, 0x01, 0x03, 0xC0, 0x03,
       0x03, 0x3C, 0x3C, 0xC0, 0xB4, 0x00, 0x03, 0xA0, 0x00, 0x00, 0x0A, 0x0A,
       0xA0, 0x3C, 0x14, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x2A, 0x1C, 0x01, 0xA4,
       0x11, 0xB4, 0x00, 0x2A, 0xAC, 0x01, 0x36, 0x2C, 0x00, 0xA4, 0x59, 0xB4,
       0x00, 0x2A, 0x1C, 0x01, 0x20, 0x0F, 0x2C, 0x00});

  // Frame 6 - 59 bytes
  printFrames.push_back(
      {0x36, 0x7C, 0x01, 0xA4, 0x11, 0xB4, 0x00, 0x36, 0x8C, 0x00, 0x2A, 0xAC,
       0x01, 0xA4, 0x05, 0xB4, 0x00, 0xA4, 0x3E, 0xB4, 0x00, 0x2A, 0x74, 0x06,
       0xA4, 0x59, 0xB4, 0x00, 0xA4, 0x05, 0xB4, 0x00, 0x2A, 0x1C, 0x01, 0x32,
       0x2C, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0xA5});
  Serial.printf("Loaded %d example frames\n", printFrames.size());
}

// ============================================================================
// BLE NOTIFICATION CALLBACK
// ============================================================================

void notifyCallback(NimBLERemoteCharacteristic *chr, uint8_t *data, size_t len,
                    bool isNotify) {
  // Store ACK
  lastAck.assign(data, data + len);
  ackReceived = true;

  Serial.print("Notification [");
  Serial.print(chr->getUUID().toString().c_str());
  Serial.print("] : ");
  for (size_t i = 0; i < len; ++i) {
    Serial.printf("%02X ", data[i]);
  }
  Serial.println();

  if (printingInProgress && chr == pNotifyChar) {
    // Wait for ACK, then send next batch
    delay(100); // Give printer time to process

    if (currentFrameIndex < printFrames.size()) {
      sendFrameBatch(currentFrameIndex);
    } else {
      Serial.println("All frames sent! Print job complete.");
      printingInProgress = false;
    }
  }
}

// ============================================================================
// PRINT JOB CONTROL
// ============================================================================

void sendFrameBatch(int startIndex) {
  if (startIndex >= printFrames.size())
    return;

  Serial.println("=== Sending Frame Batch ===");

  // Send first frame (should be regular)
  const auto &firstFrame = printFrames[startIndex];
  if (isRegularFrame(firstFrame)) {
    pWriteChar->writeValue(firstFrame.data(), firstFrame.size(), false);
    Serial.printf("Sent regular frame %d (%d bytes)\n", startIndex + 1,
                  (int)firstFrame.size());
    currentFrameIndex = startIndex + 1;

    // Send any continuation frames immediately
    while (currentFrameIndex < printFrames.size() &&
           isContinuationFrame(printFrames[currentFrameIndex])) {
      delay(20); // Small delay between continuation frames
      const auto &contFrame = printFrames[currentFrameIndex];
      pWriteChar->writeValue(contFrame.data(), contFrame.size(), false);
      Serial.printf("Sent continuation frame %d (%d bytes)\n",
                    currentFrameIndex + 1, (int)contFrame.size());
      currentFrameIndex++;
    }

    Serial.println("=== Batch Complete ===");
  } else {
    Serial.println("Error: Expected regular frame at batch start!");
  }
}

// Start printing the prepared frames
bool startPrintJob() {
  if (!pWriteChar) {
    Serial.println("No write characteristic available!");
    return false;
  }

  if (printFrames.empty()) {
    Serial.println("No frames prepared! Call prepareFramesFromBitmap() first.");
    return false;
  }

  currentFrameIndex = 0;
  printingInProgress = true;

  // Send first batch immediately
  sendFrameBatch(0);

  return true;
}

// High-level: Prepare and print in one call
bool printBitmap(const Bitmap &userBitmap) {
  if (!prepareFramesFromBitmap(userBitmap)) {
    return false;
  }
  return startPrintJob();
}

// ============================================================================
// BLE SCANNER & CONNECTION
// ============================================================================

class PrinterAdvertisedDeviceCallbacks : public NimBLEScanCallbacks {
  void onResult(NimBLEAdvertisedDevice *advertisedDevice) {
    Serial.print("Found device: ");
    Serial.println(advertisedDevice->toString().c_str());

    if (PRINTER_MAC[0] != '\0' &&
        advertisedDevice->getAddress().toString() == std::string(PRINTER_MAC)) {
      Serial.println("Found target printer, stopping scan...");
      NimBLEDevice::getScan()->stop();
    }
  }
};

void startScanner() {
  NimBLEScan *pScan = NimBLEDevice::getScan();
  pScan->setScanCallbacks(new PrinterAdvertisedDeviceCallbacks());
  pScan->setInterval(45);
  pScan->setWindow(15);
  pScan->setActiveScan(true);
  pScan->start(5, false);
}

void startConnectionFindServices() {
  NimBLEAddress addr(std::string(PRINTER_MAC), BLE_ADDR_PUBLIC);
  pClient = NimBLEDevice::createClient();

  Serial.print("Connecting to printer: ");
  Serial.println(addr.toString().c_str());

  if (!pClient->connect(addr)) {
    Serial.println("Failed to connect.");
    return;
  }
  Serial.println("Connected!");

  uint16_t mtu = pClient->getMTU();
  Serial.printf("Negotiated MTU: %u\n", mtu);

  // Find printer service (UUID 0xABF0)
  pPrinterService = pClient->getService("ABF0");
  if (!pPrinterService) {
    Serial.println("Printer service (0xABF0) not found!");
    return;
  }
  Serial.println("Printer service found.");

  // Get write characteristic (ABF1)
  pWriteChar = pPrinterService->getCharacteristic("ABF1");
  if (!pWriteChar) {
    Serial.println("Write characteristic ABF1 not found!");
    return;
  }
  Serial.println("Write characteristic ABF1 found.");

  // Get notify characteristic (ABF2)
  pNotifyChar = pPrinterService->getCharacteristic("ABF2");
  if (!pNotifyChar) {
    Serial.println("Notify characteristic ABF2 not found!");
    return;
  }
  Serial.println("Notify characteristic ABF2 found.");

  // Subscribe to notifications
  if (pNotifyChar->canNotify()) {
    if (pNotifyChar->subscribe(true, notifyCallback)) {
      Serial.println("Subscribed to ABF2 notifications.");
    } else {
      Serial.println("Subscribe to ABF2 failed.");
    }
  }
}

void beginBLESniffer() {
  Serial.println("Starting BLE...");
  NimBLEDevice::init("ESP32-Printer");

  startScanner();
  if (PRINTER_MAC[0] != '\0') {
    startConnectionFindServices();
  }
}

// Check if printer is connected
bool isPrinterConnected() {
  return pClient != nullptr && pClient->isConnected();
}

// Check if currently printing
bool isPrinting() { return printingInProgress; }
